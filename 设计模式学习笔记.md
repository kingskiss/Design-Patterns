# 设计模式

## 一、面向对象设计原则

1.依赖倒置原则(DIP)

- 高层模块不应该依赖于底层模块，二者都应该依赖于抽象。

- 抽象不应该依赖于实现细节，实现细节应该依赖于抽象。

2.开放封闭原则（OCP）

- 对扩展开发，对更改封闭。

- 类模块应该是可扩展，但是不可修改。

3.单一职责原则（SRP)

- 一个类应该仅有一个引起它变化的原因。

- 变化的方向隐含着类的责任。

4.Liskov替换原则（LSP）

- 子类必须能够替换它们的基类（IS-A）

- 继承表达类型抽象

5.接口隔离原则

- 不应该强迫客户程序依赖它们不用的方法。

- 接口应该小而完备。

6.优先使用对象组合，而不是类继承

- 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。

- 继承在某种程度上破坏了封装性，子类父类耦合度高。

- 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

## 二、23种设计模式

### 创建型

### 结构型

### 行为型

## 三、从封装变化角度对模式分类

### 1.组件协作

现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，

来实现框架与应用之间的松耦合，是二者之间协作时的常用模式。

- **Template Method	模板模式**

    描述：定义一个操作中的算法的骨架（`稳定`），而将一些步骤延迟（`变化`）到子类中。<br>
    Template Method使得子类可以不改变（`复用`）一个算法的结构即可重定义（`override重写`）<br>
    该算法的某些特定步骤。

    要点总结：

    > Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。<br>
    > 它用最简洁的机制（虚函数的多态）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。
    > 除了可以灵活应对子步骤的变化外，“不要调用我，让我调用你”的反向控制结构是其典型应用。
    > 在具体表现方面，被Template Method调用的虚方法可以实现，也可以没有任何实现(抽象，纯虚)，<br>
    > 但是推荐将它们设置为protected方法。

- **Strategy 策略模式**

    描述：定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换（`变化`）。<br>
    该模式使得算法可以独立于使用它的客户程序（`稳定`）而变化。

    要点总结：

    > Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时<br>
    > 方便地根据需要在各个算法之间进行切换。
    > Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。<br>
    > 含有许多条件判断语句的代码通常都需要Strategy模式。
    > 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省开销。

- **Observer/Event 观察者/事件模式**

	描述:定义对象间的一种一对多（`变化`）的依赖关系，以便当一个对象（Subject）的状态发生改变时，<br>
	所有依赖于它的对象都得到通知并自动更新。
	
	要点总结：
	> 使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，<br>
	> 从而使二者之间的依赖关系达到松耦合
	> 目标发送通知时，无需指定观察者，通知（可以携带信息通知作为参数）会自动传播。
	> 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
	> Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。

### 2.单一职责

在软件组件的设计中，如果责任划分不清晰，使用继承得到的结果往往是随着需求的变化，<br>
子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。

- **Decorator 装饰模式**

- **Bridge 桥模式**

### 3.对象创建

- **Factory Method 工厂模式**

- **Abstract Factory 抽象模式**

- **Prototype**

- **Builder 建造模式**

### 4.对象性能

- **Singleton 单例模式**

- **Flyweight**

### 5.接口隔离

- **Facade**

- **Proxy 代理模式**

- **Mediator**

- **Adapter**

### 6.状态变化

- **Memento**

- **State**

### 7.数据结构

- **Composite**

- **Iterator**

- **Chain of Resposibility**

### 8.行为变化

- **Command**

- **Visitor**

### 9.领域问题

- **Interpreter**

## 四、重构关键技法

- 静态->动态

- 早绑定->晚绑定

- 继承->组合

- 编译时依赖->运行时依赖

- 紧耦合->松耦合

