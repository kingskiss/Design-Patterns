# 设计模式

## 一、面向对象设计原则

1.依赖倒置原则(DIP)

- 高层模块不应该依赖于底层模块，二者都应该依赖于抽象。

- 抽象不应该依赖于实现细节，实现细节应该依赖于抽象。

2.开放封闭原则（OCP）

- 对扩展开发，对更改封闭。

- 类模块应该是可扩展，但是不可修改。

3.单一职责原则（SRP)

- 一个类应该仅有一个引起它变化的原因。

- 变化的方向隐含着类的责任。

4.Liskov替换原则（LSP）

- 子类必须能够替换它们的基类（IS-A）

- 继承表达类型抽象

5.接口隔离原则

- 不应该强迫客户程序依赖它们不用的方法。

- 接口应该小而完备。

6.优先使用对象组合，而不是类继承

- 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。

- 继承在某种程度上破坏了封装性，子类父类耦合度高。

- 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

## 二、23种设计模式

### 创建型

### 结构型

### 行为型

## 三、从封装变化角度对模式分类

### 1.组件协作

现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，

来实现框架与应用之间的松耦合，是二者之间协作时的常用模式。

- **Template Method	模板模式**

    定义：定义一个操作中的算法的骨架（`稳定`），而将一些步骤延迟（`变化`）到子类中。<br>
    Template Method使得子类可以不改变（`复用`）一个算法的结构即可重定义（`override重写`）<br>
    该算法的某些特定步骤。

    要点总结：

    > Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。<br>
    > 它用最简洁的机制（虚函数的多态）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。
    > 
    > 除了可以灵活应对子步骤的变化外，“不要调用我，让我调用你”的反向控制结构是其典型应用。
    > 
    > 在具体表现方面，被Template Method调用的虚方法可以实现，也可以没有任何实现(抽象，纯虚)，<br>
    > 但是推荐将它们设置为protected方法。

	> 比如程序执行流程固定，由子类去实现其中的一些步骤（进行变化）。

- **Strategy 策略模式**

    定义：定义一系列算法，把它们一个个封装起来，并且使它们可以互相替换（`变化`）。<br>
    该模式使得算法可以独立于使用它的客户程序（`稳定`）而变化。

    要点总结：

    > Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时<br>
    > 方便地根据需要在各个算法之间进行切换。
    > 
    > Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。<br>
    > 
    > 含有许多条件判断语句的代码通常都需要Strategy模式。
    > 
    > 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省开销。

	> 比如很多ifelse的税率计算，就可以分开成不同子类计算。运行时由父类指针指向子类对象。

- **Observer/Event 观察者/事件模式**

	定义:定义对象间的一种一对多（`变化`）的依赖关系，以便当一个对象（Subject）的状态发生改变时，<br>
	所有依赖于它的对象都得到通知并自动更新。
	
	要点总结：
	> 使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，<br>
	> 从而使二者之间的依赖关系达到松耦合
	> 
	> 目标发送通知时，无需指定观察者，通知（可以携带信息通知作为参数）会自动传播。
	> 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
	> 
	> Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。

	> 比如指挥官得知敌情之后，调用接口类的Notify方法通知所有订阅了敌情消息的下属。

### 2.单一职责

在软件组件的设计中，如果责任划分不清晰，使用继承得到的结果往往是随着需求的变化，<br>
子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。

- **Decorator 装饰模式**

	动机：在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入静态特征,<br>
	使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（<br>
	扩展功能的组合）会导致更多子类的膨胀。
	
	如何使“对象功能的扩展”能够根据需求来动态的实现？同时避免“扩展功能的增多”带来的子类膨胀问题？<br>
	从而使得任何“功能扩展变化”所导致的影响降为最低？
	
	定义：动态（`组合`）地给一个对象添加一些额外的职责。就增加功能而言，Decorator模式比<br>
	生成子类（`继承`）更为灵活（消除重复代码&减少子类个数）。


	要点总结：
	> 通过采用组合而非继承的手法，Decorator模式实现了再运行时动态扩展对象功能的能力，<br>
	> 而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生”的问题。

	> Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类<br>
	> 所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外<br>
	> 一个Component类。

	> Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于<br>
	> 解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。

	> 比如动物类，有猫，狗，熊...等子类，然后又可以派生出会吃的猫/狗/熊，会跳的猫/狗/熊，<br>
	> 会睡的猫/狗/熊等倍数增长的子类。它们在派生的本质上根本不是一个方向，所以应该用组合，<br>
	> 而不是派生。分别创建吃/跳/睡的动物类（继续向上抽象，抽取共同内容，建立Decorator类），<br>
	> 然后在运行时组合猫/狗/熊。
	
- **Bridge 桥模式**

	动机：由于某些类型的固有实现逻辑，使得它们具有两个变化的维度，乃至多个维度的变化。<br>
	如何应对这种“多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿用两个乃至多个方向变化，<br>
	而不是引入额外的复杂度？
	
	定义：将抽象部分（`业务功能`）与实现部分（`平台实现`）分离，使它们都可以独立地变化。

	要点总结：
	> Bridge模式使得“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以<br>
	> 沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，即“子类化”它们。

	> Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），<br>
	> 复用性较差。Bridge模式是比多继承方案更好的解决方法。

	> Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，<br>
	> 这时可以使用Bridge的扩展模式。

	> 比如AbstractPlatform把属性和motion分离，使它们都可以独立地变化。AirCraft属性下可以有<br>
	> 2种不同的motion，Mission属性下可以有4种motion。
	

### 3.对象创建
通过“对象创建”模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），<br>
从而支持对象创建的稳定。它是接口抽象之后的第一步工作。


- **Factory Method 工厂模式**
 
	动机：在软件系统中，经常面临这创建对象的工作。由于需求的变化，需要创建的对象的具体类型经常变化。

	如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种<br>
	“具体对象创建工作”的紧耦合？

	定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟<br>
	（目的：解耦，手段：虚函数）到子类。

	要点总结：
	> Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，<br>
	> 紧耦合的关系（new）会导致软件的脆弱。

	> Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种<br>
	> 扩展（而非更改）的策略，较好地解决了这种紧耦合关系。

	> Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。

	> 比如一个窗口程序，在里面想要分别呈现各种控件（button、label、list...），那么如果<br>
	> 把窗口和具体控件绑定起来，要写3个窗口类，在其中分别创建3种控件。如果把窗口和具体控件<br>
	> 分离开来，在窗口类中使用Factory Method（工厂基类）创建control类（控件基类），<br>
	> 那么只需要一个窗口类，然后在实例化的时候，通过传入具体工厂类（如buttonFactory），<br>
	> 就可以创造特定的具体控件展示窗口。这样就把窗口和控件分离开来，以后需要展示其他控件，<br>
	> 就只需要实现其他控件的Factory类。


- **Abstract Factory 抽象工厂模式**

	动机：在软件系统中，经常面临着“一系列互相依赖的对象”的创建工作；同事，由于需求的变化，<br>
	往往存在更多系列对象的创建工作。

	如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种“封装机制”来避免<br>
	客户程序和这种“多系列具体对象创建工作”的紧耦合？

	定义：提供一个接口，让该接口负责创建一系列“相关或者互相依赖的对象”，无需指定它们具体的类。


	要点总结：
	> 如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory模式，<br>
	> 这时候使用简单的工厂完全可以。

	
	> “系列对象”指的是在某一特定系列下的对象之间有互相依赖、或作用的关系。不同系列的对象<br>
	> 之间不能互相依赖。
	>  
	> Abstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。
	> 
	> 比如在客户程序要中要访问数据库，需要创建一系列数据库操作对象（connect，command，reader）。<br>
	> 如果客户程序需要支持访问多种数据库（sqlsever,orcle,mysql），那么在客户程序中<br>
	> 就不能创建具体的数据库类。这时就需要用到工厂模式来创建。但是这时候需要创建的一系列对象<br>
	> 都是互相依赖的，所以使用Abstract Factory模式，通过一个抽象工厂来创建这一系列对象。<br>
	> 类似工厂模式，给客户程序传入一个sqlseverFactory，那么就创建一系列sqlsever对象。


- **Prototype 原型模式**

	动机：在软件系统中，经常面临着“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象<br>
	经常面临着剧烈的变化（比如对象有很多状态），但是它们却拥有比较稳定一致的接口。

	如何应对这种变化？如何向“客户程序”（使用这些对象的程序）隔离出“这些易变对象”，从而使得<br>
	“依赖这些易变对象的客户程序”不随着需求改变而改变？

	定义：使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。


	要点总结：
	> Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，他同样<br>
	> 要求这些“易变类”拥有“稳定的接口”。
	> 
	> Prototype模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以<br>
	> 非常灵活地动态创建“拥有某些稳定接口”的新对象————所需工作仅仅是注册一个新类的对象（即原型），<br>
	> 然后在任何需要的地方Clone。
	> 
	> Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。
	> 
	> Prototype原型模式的使用与Factory Method非常类似，唯一区别是Prototype模式适应于创建复杂对象。


- **Builder 构建器模式**

	动机：在软件系统中，有时候面临这“一个复杂对象”的创建工作，其通常由各个部分的子对象用<br>
	一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们<br>
	组合在一起的算法却相对稳定。

	如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中<br>
	“稳定构建算法”不随着需求改变而改变？

	定义：将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示。


	要点总结：
	> Builder模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，<br>
	> 而复杂对象的各个部分则经常变化。

	> 变化点在哪里，封装哪里——Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。<br>
	> 其缺点在于难以应对“分步骤构建算法”的需求变动。
	>  
	> 在Builder模式中，要注意不同预言中构造器内调用虚函数的差别。
	> 
	> 比如在游戏中要创建很多不同类型的房子，由于每种房子的构建顺序（算法）稳定，都是先地面，<br>
	> 然后墙，最后屋顶。那么就可以使用构建器来专门构建房子，只需要传入不同的房子对象，<br>
	> 它就能按照顺序创建出房子。

	> 感觉上来将，Builder模式就是比Factory Method模式创建对象的时候，多了一系列相同步骤的<br>
	> “初始化”工作。

### 4.对象性能

- **Singleton 单例模式**

- **Flyweight**

### 5.接口隔离

- **Facade**

- **Proxy 代理模式**

- **Mediator**

- **Adapter**

### 6.状态变化

- **Memento**

- **State**

### 7.数据结构

- **Composite**

- **Iterator**

- **Chain of Resposibility**

### 8.行为变化

- **Command**

- **Visitor**

### 9.领域问题

- **Interpreter**

## 四、重构关键技法

- 静态->动态

- 早绑定->晚绑定

- 继承->组合

- 编译时依赖->运行时依赖

- 紧耦合->松耦合

